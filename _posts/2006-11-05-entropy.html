--- 
layout: post
meta: {}

status: publish
tags: 
- Development
- Rails
- RailsConf
- Rants
- Software
title: Entropy
type: post
published: true
---
I began my collegiate career as a Chemistry major - the <a href="http://www.csbsju.edu/chemistry/curriculum/buildtour/default.htm">shinny new chem center</a> combined with the fact that a degree in Computer Science required more than a minor in math got me thinking that mixing known carcinogens was as good a way as any to spend four years.  But then I hit <a href="http://en.wikipedia.org/wiki/Organic_chemistry">O chem</a> and the powers that be reduced the math content significantly so off I went to the land of compilers.  Needless to say, I took a rather, ahh unique, path through the major and while the finer points of circuit design have been lost to the ether, bits of my chemistry training still stick.  For some reason, I still remember when the concepts of <a href="http://en.wikipedia.org/wiki/Entropy">entropy</a> and <a href="http://en.wikipedia.org/wiki/Enthalpy">enthalpy</a> were introduced during that first year chem class...

Needless to say, I was taken in by <a href="http://memeagora.blogspot.com/">Neal Ford</a>'s <a href="http://memeagora.blogspot.com/2006/11/entropic-software.html">Entropic Software</a> post.  Neal uses an interesting example to discuss the similarities between the technical definitions of entropy and information to support his central tenant that "software breeds entropy".  He continues by comparing the design of Unix and it's history of "<a href="http://www.faqs.org/docs/artu/minilanguageschapter.html">mini languages</a>" to Windows and its (I'll say it - clunky) approach to interoperating (I couldn't help but think of Martin Fowler's <a href="http://blog.scribestudio.com/articles/2006/07/03/martin-fowler-railsconf-2006-keynote-address">keynote from RailsConf</a> along with his discussion of <a href="http://www.martinfowler.com/bliki/DomainSpecificLanguage.html">DSLs</a>).  The moral of the story?  <a href="http://en.wikipedia.org/wiki/KISS_principle">Keep it simple</a>...ah you know the rest.

The nature of the universe is towards disorder (told you I remembered something from that chem class) and I have to agree with Neal that software tends towards complexity.  Some of this is our fault - for whatever reason people in this line of work reallllly like complexity (often for it's own sake) but the ephemeral nature of software doesn't help (c'mon how many of us have added just "one more feature" since it wouldn't be _that_ hard).  Though he doesn't explicitly mention it (until the comments) part of why <a href="http://www.rubyonrails.org/">Rails</a> rocks is that it adheres so strongly to the principle of simplicity.

While I certainly don't know <strong>*what*</strong> technology will be the king in five years (even if I did I'd keep it quiet until I was able to write the definitive book on the subject) it is clear that Rails has had a major impact on how we write software.  As I mentioned in my <a href="http://ntschutta.com/jat/2006/06/10/reflections-on-javaone/">JavaOne recap</a>, everyone is trying to "prove" that their approach is just as easy as Rails (or they try point out how it isn't enterprisey enough).  Neal's dead right - software wants to be complex and it takes a concentrated effort by engaged developers to do that.  Let's hope more of us are inspired by the diligence of the Rails team towards this end.
